<!DOCTYPE HTML>
<html>

<head><meta name="generator" content="Hexo 3.8.0">
	<link rel="bookmark" type="image/x-icon" href="/img/logo.jpg">
	<link rel="shortcut icon" href="/img/logo.jpg">
	
			    <title>
    Loren2o's Blog
    </title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <link rel="stylesheet" href="/css/mic_main.css">
    <link rel="stylesheet" href="/css/dropdownMenu.css">
    <meta name="keywords" content="Loren2o">
    
    	<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
	 
    <noscript>
        <link rel="stylesheet" href="/css/noscript.css">
    </noscript>
    <style type="text/css">
        body:before {
          content: ' ';
          position: fixed;
          top: 0;
          background: url('/img/bg.jpg') center 0 no-repeat;
          right: 0;
          bottom: 0;
          left: 0;
          background-size: cover; 
        }
    </style>

			    
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script async type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


    <script src="/js/jquery.min.js"></script>
    <script src="/js/jquery.scrollex.min.js"></script>
    <script src="/js/jquery.scrolly.min.js"></script>
    <script src="/js/skel.min.js"></script>
    <script src="/js/util.js"></script>
    <script src="/js/main.js"></script>
	
</head>
    
		
<!-- Layouts -->



<!--  代码渲染  -->
<link rel="stylesheet" href="/css/prism_coy.css">
<link rel="stylesheet" href="/css/typo.css">
<!-- 文章页 -->
<body class="is-loading">
    <!-- Wrapper 外包 s-->
    <div id="wrapper" class="fade-in">
        <!-- Intro 头部显示 s -->
        <!-- Intro 头部显示 e -->
        <!-- Header 头部logo start -->
        <header id="header">
    <a href="/" class="logo">Loren2o</a>
</header>
        <!-- Nav 导航条 start -->
        <nav id="nav" class="special">
            <ul class="menu links">
			<!-- Homepage  主页  --> 
			<li>
	            <a href="/" rel="nofollow">主页</a>
	        </li>
			<!-- categories_name  分类   --> 
	        
	        <li class="active">
	            <a href="#s1">分类</a>
	                    <ul class="submenu">
	                        <li>
	                        
	                    </li></ul>
	        </li>
	        
	        <!-- archives  归档   --> 
	        
	        
		        <!-- Pages 自定义   -->
		        
		        <li>
		            <a href="/tag/" title="标签">
		                标签
		            </a>
		        </li>
		        


            </ul>
            <!-- icons 图标   -->
			<ul class="icons">
                    
			</ul>
</nav>

        <div id="main">
            <div class="post_page_title_img" style="height: 25rem;background-image: url();background-position: center; background-repeat:no-repeat; background-size:cover;-moz-background-size:cover;overflow:hidden;">
                <a href="#" style="padding: 4rem 4rem 2rem 4rem ;"><h2>Django之ORM</h2></a>
            </div>
            <!-- Post -->
            <div class="typo" style="padding: 3rem;">
                <h1 id="Object-Relational-Mapping-ORM"><a href="#Object-Relational-Mapping-ORM" class="headerlink" title="Object Relational Mapping(ORM)"></a>Object Relational Mapping(ORM)</h1><h2 id="ORM介绍"><a href="#ORM介绍" class="headerlink" title="ORM介绍"></a>ORM介绍</h2><h3 id="ORM概念"><a href="#ORM概念" class="headerlink" title="ORM概念"></a>ORM概念</h3><p>对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。<br>简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。<br>ORM在业务逻辑层和数据库层之间充当了桥梁的作用。</p>
<h3 id="ORM由来"><a href="#ORM由来" class="headerlink" title="ORM由来"></a>ORM由来</h3><p>让我们从O/R开始。字母O起源于”对象”(Object)，而R则来自于”关系”(Relational)。</p>
<p>几乎所有的软件开发过程中都会涉及到对象和关系数据库。在用户层面和业务逻辑层面，我们是面向对象的。当对象的信息发生变化的时候，我们就需要把对象的信息保存在关系数据库中。</p>
<p>按照之前的方式来进行开发就会出现程序员会在自己的业务逻辑代码中夹杂很多SQL语句用来增加、读取、修改、删除相关数据，而这些代码通常都是极其相似或者重复的。</p>
<h3 id="ORM的优势"><a href="#ORM的优势" class="headerlink" title="ORM的优势"></a>ORM的优势</h3><p>ORM解决的主要问题是对象和关系的映射。它通常将一个类和一张表一一对应，类的每个实例对应表中的一条记录，类的每个属性对应表中的每个字段。<br>ORM提供了对数据库的映射，不用直接编写SQL代码，只需操作对象就能对数据库操作数据。<br>让软件开发人员专注于业务逻辑的处理，提高了开发效率。</p>
<h3 id="ORM的劣势"><a href="#ORM的劣势" class="headerlink" title="ORM的劣势"></a>ORM的劣势</h3><p>ORM的缺点是会在一定程度上牺牲程序的执行效率。<br>ORM的操作是有限的，也就是ORM定义好的操作是可以完成的，一些复杂的查询操作是完成不了。<br>ORM用多了SQL语句就不会写了，关系数据库相关技能退化…</p>
<h3 id="ORM总结"><a href="#ORM总结" class="headerlink" title="ORM总结"></a>ORM总结</h3><p>ORM只是一种工具，工具确实能解决一些重复，简单的劳动。这是不可否认的。<br>但我们不能指望某个工具能一劳永逸地解决所有问题，一些特殊问题还是需要特殊处理的。<br>但是在整个软件开发过程中需要特殊处理的情况应该都是很少的，否则所谓的工具也就失去了它存在的意义。</p>
<h2 id="Django中的ORM"><a href="#Django中的ORM" class="headerlink" title="Django中的ORM"></a>Django中的ORM</h2><h3 id="Django项目使用MySQL数据库"><a href="#Django项目使用MySQL数据库" class="headerlink" title="Django项目使用MySQL数据库"></a>Django项目使用MySQL数据库</h3><ol>
<li><p>在Django项目的settings.py文件中，配置数据库连接信息：</p>
<pre><code>DATABASES = {
    &quot;default&quot;: {
        &quot;ENGINE&quot;: &quot;django.db.backends.mysql&quot;,
        &quot;NAME&quot;: &quot;你的数据库名称&quot;,  # 需要自己手动创建数据库
        &quot;USER&quot;: &quot;数据库用户名&quot;,
        &quot;PASSWORD&quot;: &quot;数据库密码&quot;,
        &quot;HOST&quot;: &quot;数据库IP&quot;,
        &quot;POST&quot;: 3306
    }
}
</code></pre></li>
<li><p>在与Django项目同名的目录下的<strong>init</strong>.py文件中写如下代码，告诉Django使用pymysql模块连接MySQL数据库:</p>
<pre><code>import pymysql

pymysql.install_as_MySQLdb()
</code></pre></li>
</ol>
<p>注：数据库迁移的时候出现一个警告</p>
<pre><code>WARNINGS: 
?: (mysql.W002) MySQL Strict Mode is not set for database connection &apos;default&apos;
HINT: MySQL&apos;s Strict Mode fixes many data integrity problems in MySQL,
such as data truncation upon insertion, 
by escalating warnings into errors. 
It is strongly recommended you activate it.
</code></pre><p>在配置中多加一个OPTIONS参数：<a href="https://docs.djangoproject.com/en/1.11/ref/databases/#setting-sql-mode" target="_blank" rel="noopener">Django官网解释</a></p>
<pre><code>&apos;OPTIONS&apos;: {
    &apos;init_command&apos;: &quot;SET sql_mode=&apos;STRICT_TRANS_TABLES&apos;&quot;},
</code></pre><h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>在Django中model是你数据的单一、明确的信息来源。它包含了你存储的数据的重要字段和行为。通常，一个模型（model）映射到一个数据库表。</p>
<p>基本情况：</p>
<p>每个模型都是一个Python类，它是django.db.models.Model的子类。<br>模型的每个属性都代表一个数据库字段。<br>综上所述，Django为您提供了一个自动生成的数据库访问API，详询<a href="https://docs.djangoproject.com/en/1.11/topics/db/queries/" target="_blank" rel="noopener">官方文档链接</a>。</p>
<p><img src="/2018/12/05/Django之ORM/1.png" alt=""></p>
<h3 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h3><p>下面这个例子定义了一个 Person 模型，包含 first_name 和 last_name。<br>        from django.db import models</p>
<pre><code>class Person(models.Model):
    first_name = models.CharField(max_length=30)
    last_name = models.CharField(max_length=30)
</code></pre><p>first_name 和 last_name 是模型的字段。每个字段被指定为一个类属性，每个属性映射到一个数据库列。<br>上面的 Person 模型将会像这样创建一个数据库表：</p>
<pre><code>CREATE TABLE myapp_person (
    &quot;id&quot; serial NOT NULL PRIMARY KEY,
    &quot;first_name&quot; varchar(30) NOT NULL,
    &quot;last_name&quot; varchar(30) NOT NULL
);
</code></pre><p>一些说明：<br>        1.表myapp_person的名称是自动生成的，如果你要自定义表名，需要在model的Meta类中指定 db_table 参数，强烈建议使用小写表名，特别是使用MySQL作为数据库时。<br>        2.id字段是自动添加的，如果你想要指定自定义主键，只需在其中一个字段中指定 primary_key=True 即可。如果Django发现你已经明确地设置了Field.primary_key，它将不会添加自动ID列。<br>        3.本示例中的CREATE TABLE SQL使用PostgreSQL语法进行格式化，但值得注意的是，Django会根据配置文件中指定的数据库类型来生成相应的SQL语句。<br>        4.Django支持MySQL5.5及更高版本。</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><h4 id="常用字段"><a href="#常用字段" class="headerlink" title="常用字段"></a>常用字段</h4><h5 id="AutoField"><a href="#AutoField" class="headerlink" title="AutoField"></a>AutoField</h5><p>自增的整形字段，必填参数primary_key=True，则成为数据库的主键。无该字段时，django自动创建。</p>
<p>一个model不能有两个AutoField字段。</p>
<h5 id="IntegerField"><a href="#IntegerField" class="headerlink" title="IntegerField"></a>IntegerField</h5><p>一个整数类型。数值的范围是 -2147483648 ~ 2147483647。</p>
<h5 id="CharField"><a href="#CharField" class="headerlink" title="CharField"></a>CharField</h5><p>字符类型，必须提供max_length参数。max_length表示字符的长度。</p>
<h5 id="DateField"><a href="#DateField" class="headerlink" title="DateField"></a>DateField</h5><p>日期类型，日期格式为YYYY-MM-DD，相当于Python中的datetime.date的实例。</p>
<p>参数：</p>
<p>auto_now：每次修改时修改为当前日期时间。<br>auto_now_add：新创建对象时自动添加当前日期时间。<br>auto_now和auto_now_add和default参数是互斥的，不能同时设置。</p>
<h5 id="DatetimeField"><a href="#DatetimeField" class="headerlink" title="DatetimeField"></a>DatetimeField</h5><p>日期时间字段，格式为YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]，相当于Python中的datetime.datetime的实例。</p>
<p>字段类型，详情可点击查询官网。</p>
<pre><code>AutoField(Field)
        - int自增列，必须填入参数 primary_key=True

    BigAutoField(AutoField)
        - bigint自增列，必须填入参数 primary_key=True

        注：当model中如果没有自增列，则自动会创建一个列名为id的列
        from django.db import models

        class UserInfo(models.Model):
            # 自动创建一个列名为id的且为自增的整数列
            username = models.CharField(max_length=32)

        class Group(models.Model):
            # 自定义自增列
            nid = models.AutoField(primary_key=True)
            name = models.CharField(max_length=32)

    SmallIntegerField(IntegerField):
        - 小整数 -32768 ～ 32767

    PositiveSmallIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)
        - 正小整数 0 ～ 32767

    IntegerField(Field)
        - 整数列(有符号的) -2147483648 ～ 2147483647

    PositiveIntegerField(PositiveIntegerRelDbTypeMixin, IntegerField)
        - 正整数 0 ～ 2147483647

    BigIntegerField(IntegerField):
        - 长整型(有符号的) -9223372036854775808 ～ 9223372036854775807

    BooleanField(Field)
        - 布尔值类型

    NullBooleanField(Field):
        - 可以为空的布尔值

    CharField(Field)
        - 字符类型
        - 必须提供max_length参数， max_length表示字符长度

    TextField(Field)
        - 文本类型

    EmailField(CharField)：
        - 字符串类型，Django Admin以及ModelForm中提供验证机制

    IPAddressField(Field)
        - 字符串类型，Django Admin以及ModelForm中提供验证 IPV4 机制

    GenericIPAddressField(Field)
        - 字符串类型，Django Admin以及ModelForm中提供验证 Ipv4和Ipv6
        - 参数：
            protocol，用于指定Ipv4或Ipv6， &apos;both&apos;,&quot;ipv4&quot;,&quot;ipv6&quot;
            unpack_ipv4， 如果指定为True，则输入::ffff:192.0.2.1时候，可解析为192.0.2.1，开启此功能，需要protocol=&quot;both&quot;

    URLField(CharField)
        - 字符串类型，Django Admin以及ModelForm中提供验证 URL

    SlugField(CharField)
        - 字符串类型，Django Admin以及ModelForm中提供验证支持 字母、数字、下划线、连接符（减号）

    CommaSeparatedIntegerField(CharField)
        - 字符串类型，格式必须为逗号分割的数字

    UUIDField(Field)
        - 字符串类型，Django Admin以及ModelForm中提供对UUID格式的验证

    FilePathField(Field)
        - 字符串，Django Admin以及ModelForm中提供读取文件夹下文件的功能
        - 参数：
                path,                      文件夹路径
                match=None,                正则匹配
                recursive=False,           递归下面的文件夹
                allow_files=True,          允许文件
                allow_folders=False,       允许文件夹

    FileField(Field)
        - 字符串，路径保存在数据库，文件上传到指定目录
        - 参数：
            upload_to = &quot;&quot;      上传文件的保存路径
            storage = None      存储组件，默认django.core.files.storage.FileSystemStorage

    ImageField(FileField)
        - 字符串，路径保存在数据库，文件上传到指定目录
        - 参数：
            upload_to = &quot;&quot;      上传文件的保存路径
            storage = None      存储组件，默认django.core.files.storage.FileSystemStorage
            width_field=None,   上传图片的高度保存的数据库字段名（字符串）
            height_field=None   上传图片的宽度保存的数据库字段名（字符串）

    DateTimeField(DateField)
        - 日期+时间格式 YYYY-MM-DD HH:MM[:ss[.uuuuuu]][TZ]

    DateField(DateTimeCheckMixin, Field)
        - 日期格式      YYYY-MM-DD

    TimeField(DateTimeCheckMixin, Field)
        - 时间格式      HH:MM[:ss[.uuuuuu]]

    DurationField(Field)
        - 长整数，时间间隔，数据库中按照bigint存储，ORM中获取的值为datetime.timedelta类型

    FloatField(Field)
        - 浮点型

    DecimalField(Field)
        - 10进制小数
        - 参数：
            max_digits，小数总长度
            decimal_places，小数位长度

    BinaryField(Field)
        - 二进制类型

字段类型
</code></pre><h3 id="自定义字段"><a href="#自定义字段" class="headerlink" title="自定义字段"></a>自定义字段</h3><p>自定义一个二进制字段，以及Django字段与数据库字段类型的对应关系。</p>
<pre><code>class UnsignedIntegerField(models.IntegerField):
    def db_type(self, connection):
        return &apos;integer UNSIGNED&apos;

# PS: 返回值为字段在数据库中的属性。
# Django字段与数据库字段类型对应关系如下：
    &apos;AutoField&apos;: &apos;integer AUTO_INCREMENT&apos;,
    &apos;BigAutoField&apos;: &apos;bigint AUTO_INCREMENT&apos;,
    &apos;BinaryField&apos;: &apos;longblob&apos;,
    &apos;BooleanField&apos;: &apos;bool&apos;,
    &apos;CharField&apos;: &apos;varchar(%(max_length)s)&apos;,
    &apos;CommaSeparatedIntegerField&apos;: &apos;varchar(%(max_length)s)&apos;,
    &apos;DateField&apos;: &apos;date&apos;,
    &apos;DateTimeField&apos;: &apos;datetime&apos;,
    &apos;DecimalField&apos;: &apos;numeric(%(max_digits)s, %(decimal_places)s)&apos;,
    &apos;DurationField&apos;: &apos;bigint&apos;,
    &apos;FileField&apos;: &apos;varchar(%(max_length)s)&apos;,
    &apos;FilePathField&apos;: &apos;varchar(%(max_length)s)&apos;,
    &apos;FloatField&apos;: &apos;double precision&apos;,
    &apos;IntegerField&apos;: &apos;integer&apos;,
    &apos;BigIntegerField&apos;: &apos;bigint&apos;,
    &apos;IPAddressField&apos;: &apos;char(15)&apos;,
    &apos;GenericIPAddressField&apos;: &apos;char(39)&apos;,
    &apos;NullBooleanField&apos;: &apos;bool&apos;,
    &apos;OneToOneField&apos;: &apos;integer&apos;,
    &apos;PositiveIntegerField&apos;: &apos;integer UNSIGNED&apos;,
    &apos;PositiveSmallIntegerField&apos;: &apos;smallint UNSIGNED&apos;,
    &apos;SlugField&apos;: &apos;varchar(%(max_length)s)&apos;,
    &apos;SmallIntegerField&apos;: &apos;smallint&apos;,
    &apos;TextField&apos;: &apos;longtext&apos;,
    &apos;TimeField&apos;: &apos;time&apos;,
    &apos;UUIDField&apos;: &apos;char(32)&apos;,
</code></pre><p>自定义一个char类型字段：<br>        class MyCharField(models.Field):<br>            “””<br>            自定义的char类型的字段类<br>            “””<br>            def <strong>init</strong>(self, max_length, <em>args, **kwargs):<br>                self.max_length = max_length<br>                super(MyCharField, self).<strong>init</strong>(max_length=max_length, </em>args, **kwargs)</p>
<pre><code>def db_type(self, connection):
    &quot;&quot;&quot;
    限定生成数据库表的字段类型为char，长度为max_length指定的值
    &quot;&quot;&quot;
    return &apos;char(%s)&apos; % self.max_length
</code></pre><p>使用自定义char类型字段：<br>        class Class(models.Model):<br>            id = models.AutoField(primary_key=True)<br>            title = models.CharField(max_length=25)</p>
<pre><code># 使用自定义的char类型的字段
cname = MyCharField(max_length=25)
</code></pre><p>创建的表结构：<br><img src="/2018/12/05/Django之ORM/2.png" alt=""></p>
<h3 id="字段参数"><a href="#字段参数" class="headerlink" title="字段参数"></a>字段参数</h3><p>字段参数，详情可点击查看<a href="https://docs.djangoproject.com/en/1.11/ref/models/fields/#field-options" target="_blank" rel="noopener">官网</a>。</p>
<pre><code>null                数据库中字段是否可以为空
db_column           数据库中字段的列名
default             数据库中字段的默认值
primary_key         数据库中字段是否为主键
db_index            数据库中字段是否可以建立索引
unique              数据库中字段是否可以建立唯一索引
unique_for_date     数据库中字段【日期】部分是否可以建立唯一索引
unique_for_month    数据库中字段【月】部分是否可以建立唯一索引
unique_for_year     数据库中字段【年】部分是否可以建立唯一索引

verbose_name        Admin中显示的字段名称
blank               Admin中是否允许用户输入为空
editable            Admin中是否可以编辑
help_text           Admin中该字段的提示信息
choices             Admin中显示选择框的内容，用不变动的数据放在内存中从而避免跨表操作
                    如：gf = models.IntegerField(choices=[(0, &apos;何穗&apos;),(1, &apos;大表姐&apos;),],default=1)

error_messages      自定义错误信息（字典类型），从而定制想要显示的错误信息；
                    字典健：null, blank, invalid, invalid_choice, unique, and unique_for_date
                    如：{&apos;null&apos;: &quot;不能为空.&quot;, &apos;invalid&apos;: &apos;格式错误&apos;}

validators          自定义错误验证（列表类型），从而定制想要的验证规则
                    from django.core.validators import RegexValidator
                    from django.core.validators import EmailValidator,URLValidator,DecimalValidator,\
                    MaxLengthValidator,MinLengthValidator,MaxValueValidator,MinValueValidator
                    如：
                        test = models.CharField(
                            max_length=32,
                            error_messages={
                                &apos;c1&apos;: &apos;优先错信息1&apos;,
                                &apos;c2&apos;: &apos;优先错信息2&apos;,
                                &apos;c3&apos;: &apos;优先错信息3&apos;,
                            },
                            validators=[
                                RegexValidator(regex=&apos;root_\d+&apos;, message=&apos;错误了&apos;, code=&apos;c1&apos;),
                                RegexValidator(regex=&apos;root_112233\d+&apos;, message=&apos;又错误了&apos;, code=&apos;c2&apos;),
                                EmailValidator(message=&apos;又错误了&apos;, code=&apos;c3&apos;), ]
                        )

字段参数
</code></pre><h3 id="Model-Meta参数"><a href="#Model-Meta参数" class="headerlink" title="Model Meta参数"></a>Model Meta参数</h3><p>这个不是很常用，如果你有特殊需要可以使用。详情点击查看<a href="https://docs.djangoproject.com/en/1.11/ref/models/options/#model-meta-options" target="_blank" rel="noopener">官网</a>。</p>
<pre><code>class UserInfo(models.Model):
    nid = models.AutoField(primary_key=True)
    username = models.CharField(max_length=32)

    class Meta:
        # 数据库中生成的表名称 默认 app名称 + 下划线 + 类名
        db_table = &quot;table_name&quot;

        # admin中显示的表名称
        verbose_name = &apos;个人信息&apos;

        # verbose_name加s
        verbose_name_plural = &apos;所有用户信息&apos;

        # 联合索引 
        index_together = [
            (&quot;pub_date&quot;, &quot;deadline&quot;),   # 应为两个存在的字段
        ]

        # 联合唯一索引
        unique_together = ((&quot;driver&quot;, &quot;restaurant&quot;),)   # 应为两个存在的字段
</code></pre><h3 id="多表关系和参数"><a href="#多表关系和参数" class="headerlink" title="多表关系和参数"></a>多表关系和参数</h3><pre><code>ForeignKey(ForeignObject) # ForeignObject(RelatedField)
    to,                 # 要进行关联的表名
    to_field=None,      # 要关联的表中的字段名称
    on_delete=None,     # 当删除关联表中的数据时，当前表与其关联的行的行为
                        - models.CASCADE，删除关联数据，与之关联也删除
                        - models.DO_NOTHING，删除关联数据，引发错误IntegrityError
                        - models.PROTECT，删除关联数据，引发错误ProtectedError
                        - models.SET_NULL，删除关联数据，与之关联的值设置为null（前提FK字段需要设置为可空）
                        - models.SET_DEFAULT，删除关联数据，与之关联的值设置为默认值（前提FK字段需要设置默认值）
                        - models.SET，删除关联数据，
                            a. 与之关联的值设置为指定值，设置：models.SET(值)
                            b. 与之关联的值设置为可执行对象的返回值，设置：models.SET(可执行对象)

                                    def func():
                                        return 10

                                    class MyModel(models.Model):
                                        user = models.ForeignKey(
                                            to=&quot;User&quot;,
                                            to_field=&quot;id&quot;
                                            on_delete=models.SET(func),)
    related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()
    related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(&apos;表名__字段名&apos;)
    limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：
                                # 如：
                        - limit_choices_to={&apos;nid__gt&apos;: 5}
                        - limit_choices_to=lambda : {&apos;nid__gt&apos;: 5}

                        from django.db.models import Q
                        - limit_choices_to=Q(nid__gt=10)
                        - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
                        - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp; Q(caption=&apos;root&apos;)
    db_constraint=True          # 是否在数据库中创建外键约束
    parent_link=False           # 在Admin中是否显示关联数据


OneToOneField(ForeignKey)
    to,                 # 要进行关联的表名
    to_field=None       # 要关联的表中的字段名称
    on_delete=None,     # 当删除关联表中的数据时，当前表与其关联的行的行为

                        ###### 对于一对一 ######
                        # 1. 一对一其实就是 一对多 + 唯一索引
                        # 2.当两个类之间有继承关系时，默认会创建一个一对一字段
                        # 如下会在A表中额外增加一个c_ptr_id列且唯一：
                                class C(models.Model):
                                    nid = models.AutoField(primary_key=True)
                                    part = models.CharField(max_length=12)

                                class A(C):
                                    id = models.AutoField(primary_key=True)
                                    code = models.CharField(max_length=1)

ManyToManyField(RelatedField)
    to,                         # 要进行关联的表名
    related_name=None,          # 反向操作时，使用的字段名，用于代替 【表名_set】 如： obj.表名_set.all()
    related_query_name=None,    # 反向操作时，使用的连接前缀，用于替换【表名】     如： models.UserGroup.objects.filter(表名__字段名=1).values(&apos;表名__字段名&apos;)
    limit_choices_to=None,      # 在Admin或ModelForm中显示关联数据时，提供的条件：
                                # 如：
                                    - limit_choices_to={&apos;nid__gt&apos;: 5}
                                    - limit_choices_to=lambda : {&apos;nid__gt&apos;: 5}

                                    from django.db.models import Q
                                    - limit_choices_to=Q(nid__gt=10)
                                    - limit_choices_to=Q(nid=8) | Q(nid__gt=10)
                                    - limit_choices_to=lambda : Q(Q(nid=8) | Q(nid__gt=10)) &amp; Q(caption=&apos;root&apos;)
    symmetrical=None,           # 仅用于多对多自关联时，symmetrical用于指定内部是否创建反向操作的字段
                                # 做如下操作时，不同的symmetrical会有不同的可选字段
                                    models.BB.objects.filter(...)

                                    # 可选字段有：code, id, m1
                                        class BB(models.Model):

                                        code = models.CharField(max_length=12)
                                        m1 = models.ManyToManyField(&apos;self&apos;,symmetrical=True)

                                    # 可选字段有: bb, code, id, m1
                                        class BB(models.Model):

                                        code = models.CharField(max_length=12)
                                        m1 = models.ManyToManyField(&apos;self&apos;,symmetrical=False)

    through=None,               # 自定义第三张表时，使用字段用于指定关系表
    through_fields=None,        # 自定义第三张表时，使用字段用于指定关系表中那些字段做多对多关系表
                                    from django.db import models

                                    class Person(models.Model):
                                        name = models.CharField(max_length=50)

                                    class Group(models.Model):
                                        name = models.CharField(max_length=128)
                                        members = models.ManyToManyField(
                                            Person,
                                            through=&apos;Membership&apos;,
                                            through_fields=(&apos;group&apos;, &apos;person&apos;),
                                        )

                                    class Membership(models.Model):
                                        group = models.ForeignKey(Group, on_delete=models.CASCADE)
                                        person = models.ForeignKey(Person, on_delete=models.CASCADE)
                                        inviter = models.ForeignKey(
                                            Person,
                                            on_delete=models.CASCADE,
                                            related_name=&quot;membership_invites&quot;,
                                        )
                                        invite_reason = models.CharField(max_length=64)
    db_constraint=True,         # 是否在数据库中创建外键约束
    db_table=None,              # 默认创建第三张表时，数据库中表的名称
</code></pre><h3 id="ORM操作"><a href="#ORM操作" class="headerlink" title="ORM操作"></a>ORM操作</h3><p>基本操作</p>
<pre><code># 增
models.Tb1.objects.create(c1=&apos;xx&apos;, c2=&apos;oo&apos;)   # 增加一条数据，可以接受字典类型数据 **kwargs
obj = models.Tb1(c1=&apos;xx&apos;, c2=&apos;oo&apos;)
obj.save()


# 查
models.Tb1.objects.get(id=123)  # 获取单条数据，不存在则报错（不建议）
models.Tb1.objects.all()  # 获取全部
models.Tb1.objects.filter(name=&apos;seven&apos;)  # 获取指定条件的数据
models.Tb1.objects.exclude(name=&apos;seven&apos;)  # 去除指定条件的数据


# 删
# models.Tb1.objects.filter(name=&apos;seven&apos;).delete()  # 删除指定条件的数据


# 改
models.Tb1.objects.filter(name=&apos;seven&apos;).update(gender=&apos;0&apos;)   # 将指定条件的数据更新，均支持 **kwargs
obj = models.Tb1.objects.get(id=1)
obj.c1 = &apos;111&apos;
obj.save()   # 修改单条数据
</code></pre><p>进阶操作</p>
<pre><code># 获取个数
#
# models.Tb1.objects.filter(name=&apos;seven&apos;).count()

# 大于，小于
#
# models.Tb1.objects.filter(id__gt=1)              # 获取id大于1的值
# models.Tb1.objects.filter(id__gte=1)              # 获取id大于等于1的值
# models.Tb1.objects.filter(id__lt=10)             # 获取id小于10的值
# models.Tb1.objects.filter(id__lte=10)             # 获取id小于10的值
# models.Tb1.objects.filter(id__lt=10, id__gt=1)   # 获取id大于1 且 小于10的值

# 成员判断in
#
# models.Tb1.objects.filter(id__in=[11, 22, 33])   # 获取id等于11、22、33的数据
# models.Tb1.objects.exclude(id__in=[11, 22, 33])  # not in

# 是否为空 isnull
# Entry.objects.filter(pub_date__isnull=True)

# 包括contains
#
# models.Tb1.objects.filter(name__contains=&quot;ven&quot;)
# models.Tb1.objects.filter(name__icontains=&quot;ven&quot;) # icontains大小写不敏感
# models.Tb1.objects.exclude(name__icontains=&quot;ven&quot;)

# 范围range
#
# models.Tb1.objects.filter(id__range=[1, 2])   # 范围bettwen and

# 其他类似
#
# startswith，istartswith, endswith, iendswith,

# 排序order by
#
# models.Tb1.objects.filter(name=&apos;seven&apos;).order_by(&apos;id&apos;)    # asc
# models.Tb1.objects.filter(name=&apos;seven&apos;).order_by(&apos;-id&apos;)   # desc

# 分组group by
#
# from django.db.models import Count, Min, Max, Sum
# models.Tb1.objects.filter(c1=1).values(&apos;id&apos;).annotate(c=Count(&apos;num&apos;))
# SELECT &quot;app01_tb1&quot;.&quot;id&quot;, COUNT(&quot;app01_tb1&quot;.&quot;num&quot;) AS &quot;c&quot; FROM &quot;app01_tb1&quot; WHERE &quot;app01_tb1&quot;.&quot;c1&quot; = 1 GROUP BY &quot;app01_tb1&quot;.&quot;id&quot;

# limit 、offset
#
# models.Tb1.objects.all()[10:20]

# regex正则匹配，iregex 不区分大小写
#
# Entry.objects.get(title__regex=r&apos;^(An?|The) +&apos;)
# Entry.objects.get(title__iregex=r&apos;^(an?|the) +&apos;)

# date
#
# Entry.objects.filter(pub_date__date=datetime.date(2005, 1, 1))
# Entry.objects.filter(pub_date__date__gt=datetime.date(2005, 1, 1))

# year
#
# Entry.objects.filter(pub_date__year=2005)
# Entry.objects.filter(pub_date__year__gte=2005)

# month
#
# Entry.objects.filter(pub_date__month=12)
# Entry.objects.filter(pub_date__month__gte=6)

# day
#
# Entry.objects.filter(pub_date__day=3)
# Entry.objects.filter(pub_date__day__gte=3)

# week_day
#
# Entry.objects.filter(pub_date__week_day=2)
# Entry.objects.filter(pub_date__week_day__gte=2)

# hour
#
# Event.objects.filter(timestamp__hour=23)
# Event.objects.filter(time__hour=5)
# Event.objects.filter(timestamp__hour__gte=12)

# minute
#
# Event.objects.filter(timestamp__minute=29)
# Event.objects.filter(time__minute=46)
# Event.objects.filter(timestamp__minute__gte=29)

# second
#
# Event.objects.filter(timestamp__second=31)
# Event.objects.filter(time__second=2)
# Event.objects.filter(timestamp__second__gte=31)

进阶操作
</code></pre><p>高级操作</p>
<pre><code># extra
# 在QuerySet的基础上继续执行子语句
# extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)

# select和select_params是一组，where和params是一组，tables用来设置from哪个表
# Entry.objects.extra(select={&apos;new_id&apos;: &quot;select col from sometable where othercol &gt; %s&quot;}, select_params=(1,))
# Entry.objects.extra(where=[&apos;headline=%s&apos;], params=[&apos;Lennon&apos;])
# Entry.objects.extra(where=[&quot;foo=&apos;a&apos; OR bar = &apos;a&apos;&quot;, &quot;baz = &apos;a&apos;&quot;])
# Entry.objects.extra(select={&apos;new_id&apos;: &quot;select id from tb where id &gt; %s&quot;}, select_params=(1,), order_by=[&apos;-nid&apos;])

举个例子：
models.UserInfo.objects.extra(
                    select={&apos;newid&apos;:&apos;select count(1) from app01_usertype where id&gt;%s&apos;},
                    select_params=[1,],
                    where = [&apos;age&gt;%s&apos;],
                    params=[18,],
                    order_by=[&apos;-age&apos;],
                    tables=[&apos;app01_usertype&apos;]
                )
                &quot;&quot;&quot;
                select 
                    app01_userinfo.id,
                    (select count(1) from app01_usertype where id&gt;1) as newid
                from app01_userinfo,app01_usertype
                where 
                    app01_userinfo.age &gt; 18
                order by 
                    app01_userinfo.age desc
                &quot;&quot;&quot;


# 执行原生SQL
# 更高灵活度的方式执行原生SQL语句
# from django.db import connection, connections
# cursor = connection.cursor()  # cursor = connections[&apos;default&apos;].cursor()
# cursor.execute(&quot;&quot;&quot;SELECT * from auth_user where id = %s&quot;&quot;&quot;, [1])
# row = cursor.fetchone()

高级操作
</code></pre><p>QuerySet相关方法</p>
<pre><code>##################################################################
# PUBLIC METHODS THAT ALTER ATTRIBUTES AND RETURN A NEW QUERYSET #
##################################################################

def all(self)
    # 获取所有的数据对象

def filter(self, *args, **kwargs)
    # 条件查询
    # 条件可以是：参数，字典，Q

def exclude(self, *args, **kwargs)
    # 条件查询
    # 条件可以是：参数，字典，Q

def select_related(self, *fields)
    性能相关：表之间进行join连表操作，一次性获取关联的数据。

    总结：
    1. select_related主要针一对一和多对一关系进行优化。
    2. select_related使用SQL的JOIN语句进行优化，通过减少SQL查询的次数来进行优化、提高性能。

def prefetch_related(self, *lookups)
    性能相关：多表连表操作时速度会慢，使用其执行多次SQL查询在Python代码中实现连表操作。

    总结：
    1. 对于多对多字段（ManyToManyField）和一对多字段，可以使用prefetch_related()来进行优化。
    2. prefetch_related()的优化方式是分别查询每个表，然后用Python处理他们之间的关系。

def annotate(self, *args, **kwargs)
    # 用于实现聚合group by查询

    from django.db.models import Count, Avg, Max, Min, Sum

    v = models.UserInfo.objects.values(&apos;u_id&apos;).annotate(uid=Count(&apos;u_id&apos;))
    # SELECT u_id, COUNT(ui) AS `uid` FROM UserInfo GROUP BY u_id

    v = models.UserInfo.objects.values(&apos;u_id&apos;).annotate(uid=Count(&apos;u_id&apos;)).filter(uid__gt=1)
    # SELECT u_id, COUNT(ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1

    v = models.UserInfo.objects.values(&apos;u_id&apos;).annotate(uid=Count(&apos;u_id&apos;,distinct=True)).filter(uid__gt=1)
    # SELECT u_id, COUNT( DISTINCT ui_id) AS `uid` FROM UserInfo GROUP BY u_id having count(u_id) &gt; 1

def distinct(self, *field_names)
    # 用于distinct去重
    models.UserInfo.objects.values(&apos;nid&apos;).distinct()
    # select distinct nid from userinfo

    注：只有在PostgreSQL中才能使用distinct进行去重

def order_by(self, *field_names)
    # 用于排序
    models.UserInfo.objects.all().order_by(&apos;-id&apos;,&apos;age&apos;)

def extra(self, select=None, where=None, params=None, tables=None, order_by=None, select_params=None)
    # 构造额外的查询条件或者映射，如：子查询

    Entry.objects.extra(select={&apos;new_id&apos;: &quot;select col from sometable where othercol &gt; %s&quot;}, select_params=(1,))
    Entry.objects.extra(where=[&apos;headline=%s&apos;], params=[&apos;Lennon&apos;])
    Entry.objects.extra(where=[&quot;foo=&apos;a&apos; OR bar = &apos;a&apos;&quot;, &quot;baz = &apos;a&apos;&quot;])
    Entry.objects.extra(select={&apos;new_id&apos;: &quot;select id from tb where id &gt; %s&quot;}, select_params=(1,), order_by=[&apos;-nid&apos;])

def reverse(self):
    # 倒序
    models.UserInfo.objects.all().order_by(&apos;-nid&apos;).reverse()
    # 注：如果存在order_by，reverse则是倒序，如果多个排序则一一倒序


def defer(self, *fields):
    models.UserInfo.objects.defer(&apos;username&apos;,&apos;id&apos;)
    或
    models.UserInfo.objects.filter(...).defer(&apos;username&apos;,&apos;id&apos;)
    #映射中排除某列数据

def only(self, *fields):
    #仅取某个表中的数据
    models.UserInfo.objects.only(&apos;username&apos;,&apos;id&apos;)
    或
    models.UserInfo.objects.filter(...).only(&apos;username&apos;,&apos;id&apos;)

def using(self, alias):
    指定使用的数据库，参数为别名（setting中的设置）


##################################################
# PUBLIC METHODS THAT RETURN A QUERYSET SUBCLASS #
##################################################

def raw(self, raw_query, params=None, translations=None, using=None):
    # 执行原生SQL
    models.UserInfo.objects.raw(&apos;select * from userinfo&apos;)

    # 如果SQL是其他表时，必须将名字设置为当前UserInfo对象的主键列名
    models.UserInfo.objects.raw(&apos;select id as nid from 其他表&apos;)

    # 为原生SQL设置参数
    models.UserInfo.objects.raw(&apos;select id as nid from userinfo where nid&gt;%s&apos;, params=[12,])

    # 将获取的到列名转换为指定列名
    name_map = {&apos;first&apos;: &apos;first_name&apos;, &apos;last&apos;: &apos;last_name&apos;, &apos;bd&apos;: &apos;birth_date&apos;, &apos;pk&apos;: &apos;id&apos;}
    Person.objects.raw(&apos;SELECT * FROM some_other_table&apos;, translations=name_map)

    # 指定数据库
    models.UserInfo.objects.raw(&apos;select * from userinfo&apos;, using=&quot;default&quot;)

    ################### 原生SQL ###################
    from django.db import connection, connections
    cursor = connection.cursor()  # cursor = connections[&apos;default&apos;].cursor()
    cursor.execute(&quot;&quot;&quot;SELECT * from auth_user where id = %s&quot;&quot;&quot;, [1])
    row = cursor.fetchone() # fetchall()/fetchmany(..)


def values(self, *fields):
    # 获取每行数据为字典格式

def values_list(self, *fields, **kwargs):
    # 获取每行数据为元祖

def dates(self, field_name, kind, order=&apos;ASC&apos;):
    # 根据时间进行某一部分进行去重查找并截取指定内容
    # kind只能是：&quot;year&quot;（年）, &quot;month&quot;（年-月）, &quot;day&quot;（年-月-日）
    # order只能是：&quot;ASC&quot;  &quot;DESC&quot;
    # 并获取转换后的时间
        - year : 年-01-01
        - month: 年-月-01
        - day  : 年-月-日

    models.DatePlus.objects.dates(&apos;ctime&apos;,&apos;day&apos;,&apos;DESC&apos;)

def datetimes(self, field_name, kind, order=&apos;ASC&apos;, tzinfo=None):
    # 根据时间进行某一部分进行去重查找并截取指定内容，将时间转换为指定时区时间
    # kind只能是 &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;
    # order只能是：&quot;ASC&quot;  &quot;DESC&quot;
    # tzinfo时区对象
    models.DDD.objects.datetimes(&apos;ctime&apos;,&apos;hour&apos;,tzinfo=pytz.UTC)
    models.DDD.objects.datetimes(&apos;ctime&apos;,&apos;hour&apos;,tzinfo=pytz.timezone(&apos;Asia/Shanghai&apos;))

    &quot;&quot;&quot;
    pip3 install pytz
    import pytz
    pytz.all_timezones
    pytz.timezone(‘Asia/Shanghai’)
    &quot;&quot;&quot;

def none(self):
    # 空QuerySet对象


####################################
# METHODS THAT DO DATABASE QUERIES #
####################################

def aggregate(self, *args, **kwargs):
# 聚合函数，获取字典类型聚合结果
from django.db.models import Count, Avg, Max, Min, Sum
result = models.UserInfo.objects.aggregate(k=Count(&apos;u_id&apos;, distinct=True), n=Count(&apos;nid&apos;))
===&gt; {&apos;k&apos;: 3, &apos;n&apos;: 4}

def count(self):
# 获取个数

def get(self, *args, **kwargs):
# 获取单个对象

def create(self, **kwargs):
# 创建对象

def bulk_create(self, objs, batch_size=None):
    # 批量插入
    # batch_size表示一次插入的个数
    objs = [
        models.DDD(name=&apos;r11&apos;),
        models.DDD(name=&apos;r22&apos;)
    ]
    models.DDD.objects.bulk_create(objs, 10)

def get_or_create(self, defaults=None, **kwargs):
    # 如果存在，则获取，否则，创建
    # defaults 指定创建时，其他字段的值
    obj, created = models.UserInfo.objects.get_or_create(username=&apos;root1&apos;, defaults={&apos;email&apos;: &apos;1111111&apos;,&apos;u_id&apos;: 2, &apos;t_id&apos;: 2})

def update_or_create(self, defaults=None, **kwargs):
    # 如果存在，则更新，否则，创建
    # defaults 指定创建时或更新时的其他字段
    obj, created = models.UserInfo.objects.update_or_create(username=&apos;root1&apos;, defaults={&apos;email&apos;: &apos;1111111&apos;,&apos;u_id&apos;: 2, &apos;t_id&apos;: 1})

def first(self):
# 获取第一个

def last(self):
# 获取最后一个

def in_bulk(self, id_list=None):
# 根据主键ID进行查找
id_list = [11,21,31]
models.DDD.objects.in_bulk(id_list)

def delete(self):
# 删除

def update(self, **kwargs):
    # 更新

def exists(self):
# 是否有结果

其他操作

QuerySet方法大全
</code></pre>
            </div>

            <!-- Post Comments -->
            
    <!-- 使用 DISQUS_CLICK -->
<div id="disqus-comment">
    <div id="disqus_thread"></div>

<!-- add animation -->
<style>
	.disqus_click_btn {
            line-height: 30px;
            margin: 0;
            min-width: 50px;
            padding: 0 14px;
            display: inline-block;
            font-family: "Roboto", "Helvetica", "Arial", sans-serif;
            font-size: 14px;
            font-weight: 400;
            text-transform: uppercase;
            letter-spacing: 0;
            overflow: hidden;
            will-change: box-shadow;
            transition: box-shadow .2s cubic-bezier(.4, 0, 1, 1), background-color .2s cubic-bezier(.4, 0, .2, 1), color .2s cubic-bezier(.4, 0, .2, 1);
            outline: 0;
            cursor: pointer;
            text-decoration: none;
            text-align: center;
            vertical-align: middle;
            border: 0;
            background: rgba(158, 158, 158, .2);
            box-shadow: 0 2px 2px 0 rgba(0, 0, 0, .14), 0 3px 1px -2px rgba(0, 0, 0, .2), 0 1px 5px 0 rgba(0, 0, 0, .12);
            color: #fff;
            background-color: #7EC0EE;
            text-shadow: 0
        }
</style>
	
<div class="btn_click_load" id="disqus_bt"> 
    <button class="disqus_click_btn">点击查看评论</button>
</div>

<!--
<script type="text/javascript">
$('.btn_click_load').click(function() {
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'loren2o.blog'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();

    document.getElementById('disqus_bt').style.display = "none";
});
</script>
-->
<script type="text/javascript">
    var disqus_config = function () {
        this.page.url = 'http://yoursite.com/2018/12/05/Django之ORM/';  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = 'http://yoursite.com/2018/12/05/Django之ORM/'; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
</script>

<script type="text/javascript">
    $('.btn_click_load').click(function() {  //click to load comments
        (function() { // DON'T EDIT BELOW THIS LINE
            var d = document;
            var s = d.createElement('script');
            s.src = '//loren2o.blog.disqus.com/embed.js';
            s.setAttribute('data-timestamp', + new Date());
            (d.head || d.body).appendChild(s);
        })();
        $('.btn_click_load').css('display','none');
    });
</script>
</div>
<style>
    #disqus-comment{
        background-color: #eee;
        padding: 2pc;
    }
</style>


        </div>
        <!-- Copyright 版权 start -->
                <div id="copyright">
            <ul>
                <li>&copy;Powered By <a href="https://hexo.io/zh-cn/" style="border-bottom: none;">hexo</a></li>
                <li>Design: <a href="http://miccall.tech " style="border-bottom: none;">miccall</a></li>
            </ul>
            
                <span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次</span>
			
        </div>
    </div>
</body>



 	
</html>
